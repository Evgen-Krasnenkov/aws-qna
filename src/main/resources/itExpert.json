[
  {
    "id": 1,
    "questionId": 1,
    "questionText": "A company is implementing an application on Amazon EC2 instances. The application needs to process incoming transactions. When the application detects a transaction that is not valid, the application must send a chat message to the company's support team. To send the message, the application needs to retrieve the access token to authenticate by using the chat API.\nA developer needs to implement a solution to store the access token. The access token must be encrypted at rest and in transit. The access token must also be accessible from other AWS accounts.\nWhich solution will meet these requirements with the LEAST management overhead?",
    "questionHint": null,
    "answers": [
      {
        "id": 1,
        "answerText": "Use an AWS Systems Manager Parameter Store SecureString parameter that uses an AWS Key Management Service (AWS KMS) AWS managed key to store the access token. Add a resource-based policy to the parameter to allow access from other accounts. Update the IAM role of the EC2 instances with permissions to access Parameter Store. Retrieve the token from Parameter Store with the decrypt flag enabled. Use the decrypted access token to send the message to the chat.",
        "isCorrect": false
      },
      {
        "id": 2,
        "answerText": "Encrypt the access token by using an AWS Key Management Service (AWS KMS) customer managed key. Store the access token in an Amazon DynamoDB table. Update the IAM role of the EC2 instances with permissions to access DynamoDB and AWS KMS. Retrieve the token from DynamoDDecrypt the token by using AWS KMS on the EC2 instances. Use the decrypted access token to send the message to the chat.",
        "isCorrect": false
      },
      {
        "id": 3,
        "answerText": "Use AWS Secrets Manager with an AWS Key Management Service (AWS KMS) customer managed key to store the access token. Add a resource-based policy to the secret to allow access from other accounts. Update the IAM role of the EC2 instances with permissions to access Secrets Manager. Retrieve the token from Secrets Manager. Use the decrypted access token to send the message to the chat.",
        "isCorrect": true
      },
      {
        "id": 4,
        "answerText": "Encrypt the access token by using an AWS Key Management Service (AWS KMS) AWS managed key. Store the access token in an Amazon S3 bucket. Add a bucket policy to the S3 bucket to allow access from other accounts. Update the IAM role of the EC2 instances with permissions to access Amazon S3 and AWS KMS. Retrieve the token from the S3 bucket. Decrypt the token by using AWS KMS on the EC2 instances. Use the decrypted access token to send the massage to the chat.",
        "isCorrect": false
      }
    ]
  },
  {
    "id": 2,
    "questionId": 2,
    "questionText": "A company is running Amazon EC2 instances in multiple AWS accounts. A developer needs to implement an application that collects all the lifecycle events of the EC2 instances. The application needs to store the lifecycle events in a single Amazon Simple Queue Service (Amazon SQS) queue in the company's main AWS account for further processing.\nWhich solution will meet these requirements?",
    "questionHint": null,
    "answers": [
      {
        "id": 5,
        "answerText": "Configure Amazon EC2 to deliver the EC2 instance lifecycle events from all accounts to the Amazon EventBridge event bus of the main account. Add an EventBridge rule to the event bus of the main account that matches all EC2 instance lifecycle events. Add the SQS queue as a target of the rule.",
        "isCorrect": false
      },
      {
        "id": 6,
        "answerText": "Use the resource policies of the SQS queue in the main account to give each account permissions to write to that SQS queue. Add to the Amazon EventBridge event bus of each account an EventBridge rule that matches all EC2 instance lifecycle events. Add the SQS queue in the main account as a target of the rule.",
        "isCorrect": false
      },
      {
        "id": 7,
        "answerText": "Write an AWS Lambda function that scans through all EC2 instances in the company accounts to detect EC2 instance lifecycle changes. Configure the Lambda function to write a notification message to the SQS queue in the main account if the function detects an EC2 instance lifecycle change. Add an Amazon EventBridge scheduled rule that invokes the Lambda function every minute.",
        "isCorrect": false
      },
      {
        "id": 8,
        "answerText": "Configure the permissions on the main account event bus to receive events from all accounts. Create an Amazon EventBridge rule in each account to send all the EC2 instance lifecycle events to the main account event bus. Add an EventBridge rule to the main account event bus that matches all EC2 instance lifecycle events. Set the SQS queue as a target for the rule.",
        "isCorrect": true
      }
    ]
  },
  {
    "id": 3,
    "questionId": 3,
    "questionText": "An application is using Amazon Cognito user pools and identity pools for secure access. A developer wants to integrate the user-specific file upload and download features in the application with Amazon S3. The developer must ensure that the files are saved and retrieved in a secure manner and that users can access only their own files. The file sizes range from 3 KB to 300 MB.\nWhich option will meet these requirements with the HIGHEST level of security?",
    "questionHint": null,
    "answers": [
      {
        "id": 9,
        "answerText": "Use S3 Event Notifications to validate the file upload and download requests and update the user interface (UI).",
        "isCorrect": false
      },
      {
        "id": 10,
        "answerText": "Save the details of the uploaded files in a separate Amazon DynamoDB table. Filter the list of files in the user interface (UI) by comparing the current user ID with the user ID associated with the file in the table.",
        "isCorrect": false
      },
      {
        "id": 11,
        "answerText": "Use Amazon API Gateway and an AWS Lambda function to upload and download files. Validate each request in the Lambda function before performing the requested operation.",
        "isCorrect": false
      },
      {
        "id": 12,
        "answerText": "Use an IAM policy within the Amazon Cognito identity prefix to restrict users to use their own folders in Amazon S3.",
        "isCorrect": true
      }
    ]
  },
  {
    "id": 4,
    "questionId": 4,
    "questionText": "A company is building a scalable data management solution by using AWS services to improve the speed and agility of development. The solution will ingest large volumes of data from various sources and will process this data through multiple business rules and transformations.\nThe solution requires business rules to run in sequence and to handle reprocessing of data if errors occur when the business rules run. The company needs the solution to be scalable and to require the least possible maintenance.\nWhich AWS service should the company use to manage and automate the orchestration of the data flows to meet these requirements?",
    "questionHint": null,
    "answers": [
      {
        "id": 13,
        "answerText": "AWS Batch",
        "isCorrect": false
      },
      {
        "id": 14,
        "answerText": "AWS Step Functions",
        "isCorrect": true
      },
      {
        "id": 15,
        "answerText": "AWS Glue",
        "isCorrect": false
      },
      {
        "id": 16,
        "answerText": "AWS Lambda",
        "isCorrect": false
      }
    ]
  },
  {
    "id": 5,
    "questionId": 5,
    "questionText": "A developer has created an AWS Lambda function that is written in Python. The Lambda function reads data from objects in Amazon S3 and writes data to an Amazon DynamoDB table. The function is successfully invoked from an S3 event notification when an object is created. However, the function fails when it attempts to write to the DynamoDB table.\nWhat is the MOST likely cause of this issue?",
    "questionHint": null,
    "answers": [
      {
        "id": 17,
        "answerText": "The Lambda function's concurrency limit has been exceeded.",
        "isCorrect": false
      },
      {
        "id": 18,
        "answerText": "DynamoDB table requires a global secondary index (GSI) to support writes.",
        "isCorrect": false
      },
      {
        "id": 19,
        "answerText": "The Lambda function does not have IAM permissions to write to DynamoDB.",
        "isCorrect": true
      },
      {
        "id": 20,
        "answerText": "The DynamoDB table is not running in the same Availability Zone as the Lambda function.",
        "isCorrect": false
      }
    ]
  },
  {
    "id": 6,
    "questionId": 6,
    "questionText": "A developer is creating an AWS CloudFormation template to deploy Amazon EC2 instances across multiple AWS accounts. The developer must choose the EC2 instances from a list of approved instance types.\nHow can the developer incorporate the list of approved instance types in the CloudFormation template?",
    "questionHint": null,
    "answers": [
      {
        "id": 21,
        "answerText": "Create a separate CloudFormation template for each EC2 instance type in the list.",
        "isCorrect": false
      },
      {
        "id": 22,
        "answerText": "In the Resources section of the CloudFormation template, create resources for each EC2 instance type in the list.",
        "isCorrect": false
      },
      {
        "id": 23,
        "answerText": "In the CloudFormation template, create a separate parameter for each EC2 instance type in the list.",
        "isCorrect": false
      },
      {
        "id": 24,
        "answerText": "In the CloudFormation template, create a parameter with the list of EC2 instance types as AllowedValues.",
        "isCorrect": true
      }
    ]
  },
  {
    "id": 7,
    "questionId": 7,
    "questionText": "A developer has an application that makes batch requests directly to Amazon DynamoDB by using the BatchGetItem low-level API operation. The responses frequently return values in the UnprocessedKeys element.\nWhich actions should the developer take to increase the resiliency of the application when the batch response includes values in UnprocessedKeys? (Choose two.)",
    "questionHint": null,
    "answers": [
      {
        "id": 25,
        "answerText": "Retry the batch operation immediately.",
        "isCorrect": false
      },
      {
        "id": 26,
        "answerText": "Retry the batch operation with exponential backoff and randomized delay.",
        "isCorrect": true
      },
      {
        "id": 27,
        "answerText": "Update the application to use an AWS software development kit (AWS SDK) to make the requests.",
        "isCorrect": false
      },
      {
        "id": 28,
        "answerText": "Increase the provisioned read capacity of the DynamoDB tables that the operation accesses.",
        "isCorrect": true
      },
      {
        "id": 29,
        "answerText": "Increase the provisioned write capacity of the DynamoDB tables that the operation accesses.",
        "isCorrect": false
      }
    ]
  },
  {
    "id": 8,
    "questionId": 8,
    "questionText": "A company is running a custom application on a set of on-premises Linux servers that are accessed using Amazon API Gateway. AWS X-Ray tracing has been enabled on the API test stage.\nHow can a developer enable X-Ray tracing on the on-premises servers with the LEAST amount of configuration?",
    "questionHint": null,
    "answers": [
      {
        "id": 30,
        "answerText": "Install and run the X-Ray SDK on the on-premises servers to capture and relay the data to the X-Ray service.",
        "isCorrect": false
      },
      {
        "id": 31,
        "answerText": "Install and run the X-Ray daemon on the on-premises servers to capture and relay the data to the X-Ray service.",
        "isCorrect": true
      },
      {
        "id": 32,
        "answerText": "Capture incoming requests on-premises and configure an AWS Lambda function to pull, process, and relay relevant data to X-Ray using the PutTraceSegments API call.",
        "isCorrect": false
      },
      {
        "id": 33,
        "answerText": "Capture incoming requests on-premises and configure an AWS Lambda function to pull, process, and relay relevant data to X-Ray using the PutTelemetryRecords API call.",
        "isCorrect": false
      }
    ]
  },
  {
    "id": 9,
    "questionId": 9,
    "questionText": "A company wants to share information with a third party. The third party has an HTTP API endpoint that the company can use to share the information. The company has the required API key to access the HTTP API.\nThe company needs a way to manage the API key by using code. The integration of the API key with the application code cannot affect application performance.\nWhich solution will meet these requirements MOST securely?",
    "questionHint": null,
    "answers": [
      {
        "id": 34,
        "answerText": "Store the API credentials in AWS Secrets Manager. Retrieve the API credentials at runtime by using the AWS SDK. Use the credentials to make the API call.",
        "isCorrect": true
      },
      {
        "id": 35,
        "answerText": "Store the API credentials in a local code variable. Push the code to a secure Git repository. Use the local code variable at runtime to make the API call.",
        "isCorrect": false
      },
      {
        "id": 36,
        "answerText": "Store the API credentials as an object in a private Amazon S3 bucket. Restrict access to the S3 object by using IAM policies. Retrieve the API credentials at runtime by using the AWS SDK. Use the credentials to make the API call.",
        "isCorrect": false
      },
      {
        "id": 37,
        "answerText": "Store the API credentials in an Amazon DynamoDB table. Restrict access to the table by using resource-based policies. Retrieve the API credentials at runtime by using the AWS SDK. Use the credentials to make the API call.",
        "isCorrect": false
      }
    ]
  },
  {
    "id": 10,
    "questionId": 10,
    "questionText": "A developer is deploying a new application to Amazon Elastic Container Service (Amazon ECS). The developer needs to securely store and retrieve different types of variables. These variables include authentication information for a remote API, the URL for the API, and credentials. The authentication information and API URL must be available to all current and future deployed versions of the application across development, testing, and production environments.\nHow should the developer retrieve the variables with the FEWEST application changes?",
    "questionHint": null,
    "answers": [
      {
        "id": 38,
        "answerText": "Update the application to retrieve the variables from AWS Systems Manager Parameter Store. Use unique paths in Parameter Store for each variable in each environment. Store the credentials in AWS Secrets Manager in each environment.",
        "isCorrect": true
      },
      {
        "id": 39,
        "answerText": "Update the application to retrieve the variables from AWS Key Management Service (AWS KMS). Store the API URL and credentials as unique keys for each environment.",
        "isCorrect": false
      },
      {
        "id": 40,
        "answerText": "Update the application to retrieve the variables from an encrypted file that is stored with the application. Store the API URL and credentials in unique files for each environment.",
        "isCorrect": false
      },
      {
        "id": 41,
        "answerText": "Update the application to retrieve the variables from each of the deployed environments. Define the authentication information and API URL in the ECS task definition as unique names during the deployment process.",
        "isCorrect": false
      }
    ]
  },
  {
    "id": 11,
    "questionId": 11,
    "questionText": "A developer writes an AWS Lambda function in Java that calls a third-party API by using an API key. The developer must keep the API key encrypted and secure from casual observation. The API key can change over time.\n\nHow can the developer meet these requirements in the MOST operationally efficient manner?",
    "questionHint": "A: Hard-coding parameters within any code is not a good practice. Lambda function artifacts are not stored with encryption at rest. While the Java code is compiled and not visible from the Lambda console, the source code is not compiled and still carries the values without encryption. Any changes to parameter values would require code modification, rebuilding, and re-deployment, which would not be operationally efficient.\n\nB: Amazon EBS volumes can be mounted by Amazon EC2 instances, but not by Lambda functions.\n\nC: While this solution provides a minor improvement over hard-coding parameters, co-packaging parameter values in a deployment artifact is not a Lambda function best practice. Lambda function artifacts are not stored with encryption at rest. Any changes to parameter values would require property file modification, rebuilding, and re-deployment, which is not operationally efficient.\n\nD: Parameter Store allows for easy externalization of parameters, such as an API key. The secure string option provides for data security by keeping the value encrypted at rest. Authorized access to the parameter is governed by IAM permissions. Parameter values can be easily changed by authorized principals at any time without requiring a re-deployment of the function, although the function would require intelligence to re-read the parameter values.",
    "answers": [
      {
        "id": 42,
        "answerText": "Store the API key directly in the Lambda function’s program code.",
        "isCorrect": false
      },
      {
        "id": 43,
        "answerText": "Store the API key in a file on an Amazon Elastic Block Store (Amazon EBS) volume. Include code to read the file when the Lambda function starts.",
        "isCorrect": false
      },
      {
        "id": 44,
        "answerText": "Store the API key in a property file that is deployed with the Java archive. Include code to read the property file when the Lambda function starts.",
        "isCorrect": false
      },
      {
        "id": 45,
        "answerText": "Store the API key as a secure string in the AWS Systems Manager Parameter Store. Include code to read the parameter when the Lambda function starts.",
        "isCorrect": true
      }
    ]
  }
]